/**
 * @author 黑洋葱
 * @version  1.0
 * @return  返回值为空
 */

public class exercise {
//	 public static void main(String args[]) {
//	 	System.out.println(a);
//	 	System.out.println("-------------------======");
//	 	System.out.println("书名\t作者\t价格\t销量\n三国\t罗贯中\t120\t1000");
//	int a = 2;
//    int b = 3;
//    if(a!=b){
//        System.out.println("a不等于b");

         //三元运算符
         int a = 3;
         int b = 4;
         int c = 5;
         int maxNum = (a > b ? a : b) > c ? (a > b ? a : b) : c;
//         System.out.println(maxNum);

                    //2月4号作业
                 /* 1、2|3=?         //3
                 * 计算步骤：先求得2的原码和3的原码
                 * 分析：2和3是int类型，所以2的原码：00000000 00000000 00000000 00000010
                 * 又因为java做按位或|运算时是用补码，正数的补码等于原码。
                 * 2的补码也是：00000000 00000000 00000000 00000010
                 * 3的原码：00000000 00000000 00000000 00000011
                 * 3的补码：00000000 00000000 00000000 00000011
                 * |操作：00000000 00000000 00000000 00000010   //2
                 *           00000000 00000000 00000000 00000011    //3
                 *           00000000 00000000 00000000 00000011     //3
                 *  最后，看结果要看原码，把补码换算成原码还是00000000 00000000 00000000 00000011
                */
//                 System.out.println(2|3);

                /*2、2^3=?           //1
                *计算步骤：先求得2的原码和3的原码
                *分析：2和3是int类型，所以2的原码：00000000 00000000 00000000 00000010
                 * 又因为计算机在做按位异或^运算时是用补码，正数的补码等于原码。
                 * 2的补码也是：00000000 00000000 00000000 00000010
                 * 3的原码：   00000000 00000000 00000000 00000011
                 * 3的补码：   00000000 00000000 00000000 00000011
                 * ^操作：00000000 00000000 00000000 00000010   //2
                 *             00000000 00000000 00000000 00000011    //3
                 *             00000000 00000000 00000000 00000001     //1
                 *  最后，看结果要看原码，把补码换算成原码还是00000000 00000000 00000000 00000001
                */
//                  System.out.println(2^3);

                 /*求~2=？    //-3
                *计算步骤：先求得2的原码
                *分析：2是int类型，所以2的原码：00000000 00000000 00000000 00000010
                * 又因为计算机在做按位取反~运算时是用补码，正数的补码等于原码。
                * 2的补码也是：00000000 00000000 00000000 00000010
                * ~操作：00000000 00000000 00000000 00000010（补码）
                *             11111111 11111111 11111111 11111101（取反，得到运算后的补码）
                *  最后，看结果要看原码，把补码换算成原码。
                * 负数的原码 = 反码取反，符号位不变
                *             11111111 11111111 11111111 11111100（反码 = 补码 - 1）
                *             10000000 00000000 00000000 00000011（取反）
                */
//                   System.out.println(~2);

                /*求2&3=？   //2
               *计算步骤：先求得2的原码和3的原码
               *分析：2和3是int类型，所以2的原码：00000000 00000000 00000000 00000010
               * 又因为计算机在做按位与&运算时是用补码，正数的补码等于原码。
               * 2的补码也是：00000000 00000000 00000000 00000010
               * 3的原码：   00000000 00000000 00000000 00000011
               * 3的补码：   00000000 00000000 00000000 00000011
               * &操作：00000000 00000000 00000000 00000010   //2
               *             00000000 00000000 00000000 00000011    //3
               *             00000000 00000000 00000000 00000010     //2
               *  最后，看结果要看原码，把补码换算成原码还是00000000 00000000 00000000 00000010
               */
//                  System.out.println(2&3);

                /*求~-5=？   //4
               *计算步骤：先求得-5的原码
               *分析：-5是int类型。
               * 所以-5的原码：10000000 00000000 00000000 00000101
               * 负数的反码等于原码符号位不变，其他位数取反
               * -5的反码：      11111111 11111111 11111111 11111010
               * 又因为计算机在做按位取反~运算时是用补码，负数的补码等于它的反码+1
               * -5的补码：      11111111 11111111 11111111 11111011（+1）
               * ~操作：11111111 11111111 11111111 11111011
               *             00000000 00000000 00000000 00000100    //4
               *  最后，看结果要看原码，把补码换算成原码：00000000 00000000 00000000 00000100
               */
//                  System.out.println(~-5);

                /*求13&7=？  //3 ×  实际是5
               *计算步骤：先求得13的原码和7的原码
               *分析：13和7是int类型，所以13的原码是：00000000 00000000 00000000 00001101    //错在原码算错了 原来算成00000000 00000000 00000000 00001011(11)
               * 又因为计算机在做按位与&运算时是用补码，正数的补码等于原码。
               * 13的补码也是：00000000 00000000 00000000 00001101
               * 7的原码：        00000000 00000000 00000000 00000111
               * 7的补码：        00000000 00000000 00000000 00000111
               * &操作：00000000 00000000 00000000 00001101   //13
               *             00000000 00000000 00000000 00000111   //7
               *             00000000 00000000 00000000 00000101   //5
               *  最后，看结果要看原码，把补码换算成原码还是00000000 00000000 00000000 00000101
               */
//                  System.out.println(13&7);


                /*求5|4=？   //5
               *计算步骤：先求得5的原码和4的原码
               *分析：5和4是int类型，所以5的原码是：00000000 00000000 00000000 00000101
               * 又因为计算机在做按位或|运算时是用补码，正数的补码等于原码。
               * 5的补码也是：00000000 00000000 00000000 00000101
               * 4的原码：      00000000 00000000 00000000 00000100
               * 4的补码：      00000000 00000000 00000000 00000100
               * |操作：00000000 00000000 00000000 00000101   //5
               *           00000000 00000000 00000000 00000100    //4
               *           00000000 00000000 00000000 00000101    //5
               *  最后，看结果要看原码，把补码换算成原码还是00000000 00000000 00000000 00000101
               */
//                  System.out.println(5|4);

               /*求-3^3=?  //-1  × 实际是-2
               *计算步骤：先求得-3的原码和3的原码
               *分析：-3和3是int类型，所以3的原码是：00000000 00000000 00000000 00000011
               * 又因为计算机在做按位异或^运算时是用补码，正数3的补码等于原码，-3的补码等于反码+1
               * 3的补码也是：00000000 00000000 00000000 00000011
               * -3的原码：     10000000 00000000 00000000 00000011
               * 负数的反码等于原码符号位不变，其他位数取反
               * -3的反码：     11111111 11111111 11111111 11111100
               * -3的补码：     11111111 11111111 11111111 11111101（+1）
               * ^操作：11111111 11111111 11111111 11111101
               *             00000000 00000000 00000000 00000011
               *             11111111 11111111 11111111 11111110
               *  最后，看结果要看原码，把补码换算成原码
               * 负数的原码等于反码符号位不变，其他位数取反
               *            11111111 11111111 11111111 11111101（反码 = 补码 - 1）
               *            10000000 00000000 00000000 00000010（原码）
               */
//                  System.out.println(-3^3);
//--------------------------------------------------------------------------------------------
                    /*2月5号作业
                    %整数模运算
                        公式：余数=a - a / b * b
                        a-a/b*b=(-7)-(-7)/2*2
                                    =(-7)-(-3)*2
                                    =(-7)+6
                                    =-1*/
//                        System.out.println(-7 % 2);    //-1

                        /*=7-7/(-2)*(-2)
                        =7-(-3)*(-2)
                        =7-6
                        =1*/
//                        System.out.println(7 % -2);    //1

                        /*=(-7)-(-7)/(-2)*(-2)
                        =(-7)-3*(-2)
                        =(-7)-(-6)
                        =-1*/
//                        System.out.println(-7 % -2);   //-1

                   /* %小数负数模运算
                    当a为小数时，公式：a % b = a － （int）(a / b) * b；
                       -8.5%-3.2=？
                       =(-8.5) - int(2.65625) * (-3.2)
                       =(-8.5) - 2 * (-3.2)
                       =(-8.5) - (-6.4)
                       =(-8.5) + 6.4
                       =-2.1 （近似）*/
//                        System.out.println(-8.5 % -3.2);

                        /*8.5 - (-2) * (-3.2)
                        = 8.5 - 6.4
                        = 2.1*/
//                        System.out.println(8.5 % -3.2);

                        /*8 - int(8/3.0) * 3.0
                        =8 - 6.0
                        =2.0*/
//                        System.out.println(8 % 3.0);


//                        除数不能为0
//                        Exception in thread "main" java.lang.ArithmeticException: / by zero
//                        System.out.println(6/0);

//                        输出特殊值Infinity。表示无穷大
//                        System.out.println(6.5 / 0);

//                        输出特殊值NaN。表示Not a Number
//                        System.out.println(0.0 / 0);

//                        输出特殊值-Infinity。表示负无穷大
//                        System.out.println(-1.0 / 0);

/*             int a = 1;
                int b = 2;
                int c = a ^ b  ^ a; //1 2 2
                int d = a ^ b  ^ b;//1 2 1
                System.out.println(c);//2
                System.out.println(d);//1*/


//     }
}